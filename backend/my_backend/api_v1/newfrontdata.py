#!/bin/python3
import sys
from pprint import pprint
from collections import OrderedDict
from sqlalchemy import inspect
from my_backend.api_v1 import model

""" # not with mysql row class
for col in inspect(class_).attrs:
    # print(col)
    key = col.key
    type_ = col.columns[0].type.python_type
    var = type_("1")
    print(i*" "+key +' : '+ repr(var) + ",")
    # dic[key] = "fillme"
"""
"""example schema() for pydantic model:
{'title': 'MyModel',
 'type': 'object',
 'properties': {'name': {'title': 'Name', 'type': 'string'},
  'num': {'title': 'Num', 'type': 'integer'},
  'num2': {'title': 'Num2', 'type': 'number'}},
 'required': ['name', 'num', 'num2']}
"""

pyd2py = { # pydantic type names to python type functions
    "string" : str,
    "integer" : int,
    "number" : float
}

def printPydanticSchema(schema):
    for name, info in schema["properties"].items():
        if name == "uuid":
            continue
        title = info["title"]
        type_ = info["type"] # "string", "integer", etc.
        pytype = pyd2py[type_] # python type: str, int, etc.
        st="""
                %s : {
                        label : '%s',
                        help  : 'todo',
                        check : this.check%s.bind(this)
                    },"""\
            % (name, title, pytype.__name__.capitalize()
            # __name__.capitalize() --> checkStr, checkInt, checkFloat
        )
        print(st)


if len(sys.argv) < 2:
    print("""
usage: ./newfrontdata.py ClassName > target.js
""")
    sys.exit(2)
classname = sys.argv[1]

# *** INPUT MOCK DATA ***

print(f"""
// this file has been autogenerated with "newfrontdata.py"
// which you can find in your backend's "api_v1/" directory
//
// command used was:
// ./newfrontdata.py {classname}
//
// TODO: you might need to correct the relative directory of "../base/lib"

import {{ DataSourceWidget }} from '../lib/base/datasourcewidget.js';
import {{ HTTPDataSourceWidget }} from '../lib/base/httpdatasourcewidget.js';

class {classname}MockDataSourceWidget extends DataSourceWidget {{
    createState() {{""")

mod=getattr(model, classname.lower())
class_=getattr(mod, classname)
cin = getattr(class_, "Cin") # pydantic model # data going into backend when doing a new create op
rout = getattr(class_, "Rout") # pydantic model # data coming from backend for each object
uin = getattr(class_, "Uin") # pydantic model # data going into backend when doing an update op

i=8
print("\n"+i*" "+"// Incoming mock data from backend")
print(i*" "+"this.data = [")
i=12
print(i*" "+"{")
i=16
schema=rout.schema()
for name, info in schema["properties"].items():
    #if name == "uuid":
    #    continue
    title = info["title"]
    type_ = info["type"] # "string", "integer", etc.
    pytype = pyd2py[type_] # python type: str, int, etc.
    var = pytype("1")
    print(i*" "+name +' : '+ repr(var) + ",")

# sys.exit(0)

i=12
print(i*" "+"},")
i=8
print(i*" "+"]; // this.data")

# *** DATA SCHEMAS FOR MOCK DATASOURCE ***
i=8
print("\n"+i*" "+"// Schema for create operations: your input forms need this")
print(i*" "+"this.datamodel_create = {")
printPydanticSchema(cin.schema())
print(i*" "+"}; // this.datamodel_create")

i=8
print("\n"+i*" "+"// Schema for read operations: what is expected from the server")
print(""+i*" "+"// There can be more data elements not described in here (like uuid)")
print(""+i*" "+"// but they should be checked/displayed in downstream widgets (i.e. they're hidden)")
print("\n"+i*" "+"// Should be consistent with your mock data")
print(i*" "+"this.datamodel_read = {")
printPydanticSchema(rout.schema())
print(i*" "+"}; // this.datamodel_read")

i=8
print("\n"+i*" "+"// Schema for update operations into the server")
print(""+i*" "+"// uuid is always assumed, so it is not listed in here")
print(i*" "+"this.datamodel_update = {")
printPydanticSchema(uin.schema())
print(i*" "+"}; // this.datamodel_update")

print("""
    }; // createState
}; // mockdatasource
""")

# sys.exit(0)

# *** DATA SCHEMAS FOR HTTP DATASOURCE ***
print(f"""
// this file has been autogenerated with "newfrontdata.py"
// which you can find in your backend's "api_v1/" directory
// command used was:
// ./newfrontdata.py {classname}

class {classname}HTTPDataSourceWidget extends HTTPDataSourceWidget {{
    declareDatamodels() {{""")

i=8
print("\n"+i*" "+"// Schema for create operations: your input forms need this")
print(i*" "+"this.datamodel_create = {")
printPydanticSchema(cin.schema())
print(i*" "+"}; // this.datamodel_create")

i=8
print("\n"+i*" "+"// Schema for read operations: data expected from server")
print(""+i*" "+"// There can be more data elements not described in here (like uuid)")
print(""+i*" "+"// but they should be checked/displayed in downstream widgets (i.e. they're hidden)")
print(i*" "+"this.datamodel_read = {")
printPydanticSchema(rout.schema())
print(i*" "+"}; // this.datamodel_read")

i=8
print("\n"+i*" "+"// Schema for update operations into the server")
print(""+i*" "+"// uuid is always assumed, so it is not listed in here")
print(i*" "+"this.datamodel_update = {")
printPydanticSchema(uin.schema())
print(i*" "+"}; // this.datamodel_update")

print("""
    }; // declareDataModels
}; // httpdatasource

export { %sMockDataSourceWidget, %sHTTPDataSourceWidget };

// import with:
// import { %sMockDataSourceWidget, %sHTTPDataSourceWidget } from './app/%sdatasources.js';
""" % (classname, classname, classname, classname, classname.lower()))

print("""// use like this:
/*
// var data_source = new %sMockDataSourceWidget() // for developing with mock data
var data_source = new %sHTTPDataSourceWidget({ // for the real-deal
    base_address: "http://0.0.0.0:8080", // for local dev session without webserver
    // base_address: "", // when using webservers
    api_slug: "api_v1",
    object_name: "%s"
    // authenticator: authenticator // TODO
})
*/
""" % (classname, classname, classname.lower()))
